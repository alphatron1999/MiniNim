Nonterminals useless in grammar

   symbolCommaNoHang


Terminals unused in grammar

   ELSEX


Rules useless in grammar

  119 symbolCommaNoHang: symbolCommaNoHang comma symbol
  120                  | symbol comma symbol


State 67 conflicts: 1 shift/reduce


Grammar

    0 $accept: module $end

    1 module: complexOrSimpleStmt
    2       | module2 INDEQ complexOrSimpleStmt
    3       | %empty

    4 module2: module2 INDEQ complexOrSimpleStmt
    5        | complexOrSimpleStmt

    6 comma: ','

    7 colon: ':'

    8 sExpr: sExpr "xor" sExpr
    9      | sExpr "or" sExpr
   10      | sExpr "and" sExpr
   11      | sExpr "!=" sExpr
   12      | sExpr '>' sExpr
   13      | sExpr ">=" sExpr
   14      | sExpr '<' sExpr
   15      | sExpr "<=" sExpr
   16      | sExpr "==" sExpr
   17      | sExpr '-' sExpr
   18      | sExpr '+' sExpr
   19      | sExpr '%' sExpr
   20      | sExpr "mod" sExpr
   21      | sExpr "div" sExpr
   22      | sExpr '/' sExpr
   23      | sExpr '*' sExpr
   24      | '+' sExpr
   25      | '-' sExpr
   26      | '$' sExpr
   27      | "not" sExpr
   28      | '(' sExpr ')'
   29      | primary

   30 symbol: IDENT

   31 exprList: expr comma exprList
   32         | expr

   33 literal: BOOLLIT
   34        | INTLIT
   35        | FLOATLIT
   36        | STRLIT
   37        | CHARLIT
   38        | "nil"

   39 identOrLiteral: symbol
   40               | literal
   41               | arrayConstr
   42               | tupleConstr

   43 tupleConstr: '(' exprList ')'

   44 arrayConstr: '[' exprList ']'

   45 primarySuffix: '(' exprList ')'
   46              | '(' ')'
   47              | '[' expr ']'
   48              | '.' symbol

   49 ifExpr: "if" condExpr

   50 condExpr: expr colon expr elifCondExpr

   51 elifCondExpr: "elif" expr colon expr elifCondExpr
   52             | "else" colon expr

   53 declColon: symbol ':' typeDesc

   54 inlTupleDecl: "tuple" '[' declColonCommaNoHang ']'

   55 arrayDecl: "array" '[' INTLIT comma typeDesc ']'

   56 paramList: '(' declColonCommaNoHang ')'
   57          | '(' ')'

   58 declColonCommaNoHang: declColon comma declColonCommaNoHang
   59                     | declColon

   60 paramListColon: paramList ':' typeDesc
   61               | ':' typeDesc
   62               | %empty

   63 $@1: %empty

   64 $@2: %empty

   65 forStmt: "for" $@1 symbol $@2 "in" expr ".." expr colonBody

   66 expr: ifExpr
   67     | sExpr

   68 primary: identOrLiteral primary2
   69        | identOrLiteral

   70 primary2: primarySuffix primary2
   71         | primarySuffix

   72 typeDesc: symbol
   73         | inlTupleDecl
   74         | arrayDecl

   75 exprStmt: sExpr
   76         | symbol '=' expr
   77         | symbol "+=" expr
   78         | symbol "*=" expr

   79 returnStmt: "return" expr
   80           | "return"

   81 breakStmt: "break"

   82 continueStmt: "continue"

   83 ifStmt: "if" expr colonBody INDEQ elifCondStmt
   84       | "if" expr colonBody INDEQ elifCondStmt "else" colonBody
   85       | "if" expr colonBody
   86       | "if" expr colonBody INDEQ "else" colonBody

   87 elifCondStmt: elifCondStmt INDEQ "elif" expr colonBody
   88             | INDEQ "elif" expr colonBody

   89 whileStmt: "while" expr colonBody

   90 routine: symbol paramListColon '=' stmt
   91        | symbol paramListColon

   92 typeDef: symbol '=' typeDesc

   93 $@3: %empty

   94 colonBody: colon $@3 stmt

   95 variable: symbol ':' typeDesc '=' expr
   96         | symbol ':' typeDesc

   97 secVariable: variable
   98            | INDG variable serVariable DED

   99 serVariable: INDEQ variable serVariable
  100            | %empty

  101 simpleStmt: returnStmt
  102           | breakStmt
  103           | continueStmt
  104           | exprStmt

  105 complexOrSimpleStmt: ifStmt
  106                    | whileStmt
  107                    | forStmt
  108                    | "echo" expr
  109                    | "proc" routine
  110                    | "type" typeDef
  111                    | "var" secVariable
  112                    | "readInt" symbol
  113                    | "readFloat" symbol
  114                    | simpleStmt

  115 stmt: simpleStmt
  116     | INDG stmt2 complexOrSimpleStmt DED

  117 stmt2: stmt2 complexOrSimpleStmt INDEQ
  118      | %empty


Terminals, with rules where they appear

$end (0) 0
'$' (36) 26
'%' (37) 19
'(' (40) 28 43 45 46 56 57
')' (41) 28 43 45 46 56 57
'*' (42) 23
'+' (43) 18 24
',' (44) 6
'-' (45) 17 25
'.' (46) 48
'/' (47) 22
':' (58) 7 53 60 61 95 96
'<' (60) 14
'=' (61) 76 90 92 95
'>' (62) 12
'[' (91) 44 47 54 55
']' (93) 44 47 54 55
error (256)
INTLIT (258) 34 55
FLOATLIT (259) 35
STRLIT (260) 36
CHARLIT (261) 37
BOOLLIT (262) 33
IDENT (263) 30
INDG (264) 98 116
INDEQ (265) 2 4 83 84 86 87 88 99 117
DED (266) 98 116
"break" (267) 81
"continue" (268) 82
"elif" (269) 51 87 88
"else" (270) 52 84 86
"for" (271) 65
"if" (272) 49 83 84 85 86
"in" (273) 65
"nil" (274) 38
"proc" (275) 109
"return" (276) 79 80
"tuple" (277) 54
"type" (278) 110
"var" (279) 111
"while" (280) 89
"echo" (281) 108
"array" (282) 55
"readInt" (283) 112
"readFloat" (284) 113
IFX (285)
ELSEX (286)
"xor" (287) 8
"or" (288) 9
"and" (289) 10
"!=" (290) 11
">=" (291) 13
"<=" (292) 15
"==" (293) 16
".." (294) 65
"mod" (295) 20
"div" (296) 21
"not" (297) 27
"+=" (298) 77
"*=" (299) 78
UPLUS (300)
UMINUS (301)
LPAREN (302)


Nonterminals, with rules where they appear

$accept (64)
    on left: 0
module (65)
    on left: 1 2 3, on right: 0
module2 (66)
    on left: 4 5, on right: 2 4
comma (67)
    on left: 6, on right: 31 55 58
colon (68)
    on left: 7, on right: 50 51 52 94
sExpr (69)
    on left: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
    27 28 29, on right: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
    23 24 25 26 27 28 67 75
symbol (70)
    on left: 30, on right: 39 48 53 65 72 76 77 78 90 91 92 95 96 112
    113
exprList (71)
    on left: 31 32, on right: 31 43 44 45
literal (72)
    on left: 33 34 35 36 37 38, on right: 40
identOrLiteral (73)
    on left: 39 40 41 42, on right: 68 69
tupleConstr (74)
    on left: 43, on right: 42
arrayConstr (75)
    on left: 44, on right: 41
primarySuffix (76)
    on left: 45 46 47 48, on right: 70 71
ifExpr (77)
    on left: 49, on right: 66
condExpr (78)
    on left: 50, on right: 49
elifCondExpr (79)
    on left: 51 52, on right: 50 51
declColon (80)
    on left: 53, on right: 58 59
inlTupleDecl (81)
    on left: 54, on right: 73
arrayDecl (82)
    on left: 55, on right: 74
paramList (83)
    on left: 56 57, on right: 60
declColonCommaNoHang (84)
    on left: 58 59, on right: 54 56 58
paramListColon (85)
    on left: 60 61 62, on right: 90 91
forStmt (86)
    on left: 65, on right: 107
$@1 (87)
    on left: 63, on right: 65
$@2 (88)
    on left: 64, on right: 65
expr (89)
    on left: 66 67, on right: 31 32 47 50 51 52 65 76 77 78 79 83 84
    85 86 87 88 89 95 108
primary (90)
    on left: 68 69, on right: 29
primary2 (91)
    on left: 70 71, on right: 68 70
typeDesc (92)
    on left: 72 73 74, on right: 53 55 60 61 92 95 96
exprStmt (93)
    on left: 75 76 77 78, on right: 104
returnStmt (94)
    on left: 79 80, on right: 101
breakStmt (95)
    on left: 81, on right: 102
continueStmt (96)
    on left: 82, on right: 103
ifStmt (97)
    on left: 83 84 85 86, on right: 105
elifCondStmt (98)
    on left: 87 88, on right: 83 84 87
whileStmt (99)
    on left: 89, on right: 106
routine (100)
    on left: 90 91, on right: 109
typeDef (101)
    on left: 92, on right: 110
colonBody (102)
    on left: 94, on right: 65 83 84 85 86 87 88 89
$@3 (103)
    on left: 93, on right: 94
variable (104)
    on left: 95 96, on right: 97 98 99
secVariable (105)
    on left: 97 98, on right: 111
serVariable (106)
    on left: 99 100, on right: 98 99
simpleStmt (107)
    on left: 101 102 103 104, on right: 114 115
complexOrSimpleStmt (108)
    on left: 105 106 107 108 109 110 111 112 113 114, on right: 1 2
    4 5 116 117
stmt (109)
    on left: 115 116, on right: 90 94
stmt2 (110)
    on left: 117 118, on right: 116 117


State 0

    0 $accept: . module $end

    INTLIT       shift, and go to state 1
    FLOATLIT     shift, and go to state 2
    STRLIT       shift, and go to state 3
    CHARLIT      shift, and go to state 4
    BOOLLIT      shift, and go to state 5
    IDENT        shift, and go to state 6
    "break"      shift, and go to state 7
    "continue"   shift, and go to state 8
    "for"        shift, and go to state 9
    "if"         shift, and go to state 10
    "nil"        shift, and go to state 11
    "proc"       shift, and go to state 12
    "return"     shift, and go to state 13
    "type"       shift, and go to state 14
    "var"        shift, and go to state 15
    "while"      shift, and go to state 16
    "echo"       shift, and go to state 17
    "readInt"    shift, and go to state 18
    "readFloat"  shift, and go to state 19
    "not"        shift, and go to state 20
    '-'          shift, and go to state 21
    '+'          shift, and go to state 22
    '$'          shift, and go to state 23
    '('          shift, and go to state 24
    '['          shift, and go to state 25

    $default  reduce using rule 3 (module)

    module               go to state 26
    module2              go to state 27
    sExpr                go to state 28
    symbol               go to state 29
    literal              go to state 30
    identOrLiteral       go to state 31
    tupleConstr          go to state 32
    arrayConstr          go to state 33
    forStmt              go to state 34
    primary              go to state 35
    exprStmt             go to state 36
    returnStmt           go to state 37
    breakStmt            go to state 38
    continueStmt         go to state 39
    ifStmt               go to state 40
    whileStmt            go to state 41
    simpleStmt           go to state 42
    complexOrSimpleStmt  go to state 43


State 1

   34 literal: INTLIT .

    $default  reduce using rule 34 (literal)


State 2

   35 literal: FLOATLIT .

    $default  reduce using rule 35 (literal)


State 3

   36 literal: STRLIT .

    $default  reduce using rule 36 (literal)


State 4

   37 literal: CHARLIT .

    $default  reduce using rule 37 (literal)


State 5

   33 literal: BOOLLIT .

    $default  reduce using rule 33 (literal)


State 6

   30 symbol: IDENT .

    $default  reduce using rule 30 (symbol)


State 7

   81 breakStmt: "break" .

    $default  reduce using rule 81 (breakStmt)


State 8

   82 continueStmt: "continue" .

    $default  reduce using rule 82 (continueStmt)


State 9

   65 forStmt: "for" . $@1 symbol $@2 "in" expr ".." expr colonBody

    $default  reduce using rule 63 ($@1)

    $@1  go to state 44


State 10

   83 ifStmt: "if" . expr colonBody INDEQ elifCondStmt
   84       | "if" . expr colonBody INDEQ elifCondStmt "else" colonBody
   85       | "if" . expr colonBody
   86       | "if" . expr colonBody INDEQ "else" colonBody

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 49
    primary         go to state 35


State 11

   38 literal: "nil" .

    $default  reduce using rule 38 (literal)


State 12

  109 complexOrSimpleStmt: "proc" . routine

    IDENT  shift, and go to state 6

    symbol   go to state 50
    routine  go to state 51


State 13

   79 returnStmt: "return" . expr
   80           | "return" .

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    $default  reduce using rule 80 (returnStmt)

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 52
    primary         go to state 35


State 14

  110 complexOrSimpleStmt: "type" . typeDef

    IDENT  shift, and go to state 6

    symbol   go to state 53
    typeDef  go to state 54


State 15

  111 complexOrSimpleStmt: "var" . secVariable

    IDENT  shift, and go to state 6
    INDG   shift, and go to state 55

    symbol       go to state 56
    variable     go to state 57
    secVariable  go to state 58


State 16

   89 whileStmt: "while" . expr colonBody

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 59
    primary         go to state 35


State 17

  108 complexOrSimpleStmt: "echo" . expr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 60
    primary         go to state 35


State 18

  112 complexOrSimpleStmt: "readInt" . symbol

    IDENT  shift, and go to state 6

    symbol  go to state 61


State 19

  113 complexOrSimpleStmt: "readFloat" . symbol

    IDENT  shift, and go to state 6

    symbol  go to state 62


State 20

   27 sExpr: "not" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 63
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 21

   25 sExpr: '-' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 64
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 22

   24 sExpr: '+' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 65
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 23

   26 sExpr: '$' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 66
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 24

   28 sExpr: '(' . sExpr ')'
   43 tupleConstr: '(' . exprList ')'

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 67
    symbol          go to state 47
    exprList        go to state 68
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 69
    primary         go to state 35


State 25

   44 arrayConstr: '[' . exprList ']'

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    exprList        go to state 70
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 69
    primary         go to state 35


State 26

    0 $accept: module . $end

    $end  shift, and go to state 71


State 27

    2 module: module2 . INDEQ complexOrSimpleStmt
    4 module2: module2 . INDEQ complexOrSimpleStmt

    INDEQ  shift, and go to state 72


State 28

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   75 exprStmt: sExpr .

    "xor"  shift, and go to state 73
    "or"   shift, and go to state 74
    "and"  shift, and go to state 75
    "!="   shift, and go to state 76
    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 75 (exprStmt)


State 29

   39 identOrLiteral: symbol .
   76 exprStmt: symbol . '=' expr
   77         | symbol . "+=" expr
   78         | symbol . "*=" expr

    "+="  shift, and go to state 89
    "*="  shift, and go to state 90
    '='   shift, and go to state 91

    $default  reduce using rule 39 (identOrLiteral)


State 30

   40 identOrLiteral: literal .

    $default  reduce using rule 40 (identOrLiteral)


State 31

   68 primary: identOrLiteral . primary2
   69        | identOrLiteral .

    '('  shift, and go to state 92
    '['  shift, and go to state 93
    '.'  shift, and go to state 94

    $default  reduce using rule 69 (primary)

    primarySuffix  go to state 95
    primary2       go to state 96


State 32

   42 identOrLiteral: tupleConstr .

    $default  reduce using rule 42 (identOrLiteral)


State 33

   41 identOrLiteral: arrayConstr .

    $default  reduce using rule 41 (identOrLiteral)


State 34

  107 complexOrSimpleStmt: forStmt .

    $default  reduce using rule 107 (complexOrSimpleStmt)


State 35

   29 sExpr: primary .

    $default  reduce using rule 29 (sExpr)


State 36

  104 simpleStmt: exprStmt .

    $default  reduce using rule 104 (simpleStmt)


State 37

  101 simpleStmt: returnStmt .

    $default  reduce using rule 101 (simpleStmt)


State 38

  102 simpleStmt: breakStmt .

    $default  reduce using rule 102 (simpleStmt)


State 39

  103 simpleStmt: continueStmt .

    $default  reduce using rule 103 (simpleStmt)


State 40

  105 complexOrSimpleStmt: ifStmt .

    $default  reduce using rule 105 (complexOrSimpleStmt)


State 41

  106 complexOrSimpleStmt: whileStmt .

    $default  reduce using rule 106 (complexOrSimpleStmt)


State 42

  114 complexOrSimpleStmt: simpleStmt .

    $default  reduce using rule 114 (complexOrSimpleStmt)


State 43

    1 module: complexOrSimpleStmt .
    5 module2: complexOrSimpleStmt .

    INDEQ     reduce using rule 5 (module2)
    $default  reduce using rule 1 (module)


State 44

   65 forStmt: "for" $@1 . symbol $@2 "in" expr ".." expr colonBody

    IDENT  shift, and go to state 6

    symbol  go to state 97


State 45

   49 ifExpr: "if" . condExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    condExpr        go to state 98
    expr            go to state 99
    primary         go to state 35


State 46

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   67 expr: sExpr .

    "xor"  shift, and go to state 73
    "or"   shift, and go to state 74
    "and"  shift, and go to state 75
    "!="   shift, and go to state 76
    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 67 (expr)


State 47

   39 identOrLiteral: symbol .

    $default  reduce using rule 39 (identOrLiteral)


State 48

   66 expr: ifExpr .

    $default  reduce using rule 66 (expr)


State 49

   83 ifStmt: "if" expr . colonBody INDEQ elifCondStmt
   84       | "if" expr . colonBody INDEQ elifCondStmt "else" colonBody
   85       | "if" expr . colonBody
   86       | "if" expr . colonBody INDEQ "else" colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 102


State 50

   90 routine: symbol . paramListColon '=' stmt
   91        | symbol . paramListColon

    ':'  shift, and go to state 103
    '('  shift, and go to state 104

    $default  reduce using rule 62 (paramListColon)

    paramList       go to state 105
    paramListColon  go to state 106


State 51

  109 complexOrSimpleStmt: "proc" routine .

    $default  reduce using rule 109 (complexOrSimpleStmt)


State 52

   79 returnStmt: "return" expr .

    $default  reduce using rule 79 (returnStmt)


State 53

   92 typeDef: symbol . '=' typeDesc

    '='  shift, and go to state 107


State 54

  110 complexOrSimpleStmt: "type" typeDef .

    $default  reduce using rule 110 (complexOrSimpleStmt)


State 55

   98 secVariable: INDG . variable serVariable DED

    IDENT  shift, and go to state 6

    symbol    go to state 56
    variable  go to state 108


State 56

   95 variable: symbol . ':' typeDesc '=' expr
   96         | symbol . ':' typeDesc

    ':'  shift, and go to state 109


State 57

   97 secVariable: variable .

    $default  reduce using rule 97 (secVariable)


State 58

  111 complexOrSimpleStmt: "var" secVariable .

    $default  reduce using rule 111 (complexOrSimpleStmt)


State 59

   89 whileStmt: "while" expr . colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 110


State 60

  108 complexOrSimpleStmt: "echo" expr .

    $default  reduce using rule 108 (complexOrSimpleStmt)


State 61

  112 complexOrSimpleStmt: "readInt" symbol .

    $default  reduce using rule 112 (complexOrSimpleStmt)


State 62

  113 complexOrSimpleStmt: "readFloat" symbol .

    $default  reduce using rule 113 (complexOrSimpleStmt)


State 63

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   27      | "not" sExpr .

    $default  reduce using rule 27 (sExpr)


State 64

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   25      | '-' sExpr .

    $default  reduce using rule 25 (sExpr)


State 65

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   24      | '+' sExpr .

    $default  reduce using rule 24 (sExpr)


State 66

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   26      | '$' sExpr .

    $default  reduce using rule 26 (sExpr)


State 67

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   28      | '(' sExpr . ')'
   67 expr: sExpr .

    "xor"  shift, and go to state 73
    "or"   shift, and go to state 74
    "and"  shift, and go to state 75
    "!="   shift, and go to state 76
    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88
    ')'    shift, and go to state 111

    ')'       [reduce using rule 67 (expr)]
    $default  reduce using rule 67 (expr)


State 68

   43 tupleConstr: '(' exprList . ')'

    ')'  shift, and go to state 112


State 69

   31 exprList: expr . comma exprList
   32         | expr .

    ','  shift, and go to state 113

    $default  reduce using rule 32 (exprList)

    comma  go to state 114


State 70

   44 arrayConstr: '[' exprList . ']'

    ']'  shift, and go to state 115


State 71

    0 $accept: module $end .

    $default  accept


State 72

    2 module: module2 INDEQ . complexOrSimpleStmt
    4 module2: module2 INDEQ . complexOrSimpleStmt

    INTLIT       shift, and go to state 1
    FLOATLIT     shift, and go to state 2
    STRLIT       shift, and go to state 3
    CHARLIT      shift, and go to state 4
    BOOLLIT      shift, and go to state 5
    IDENT        shift, and go to state 6
    "break"      shift, and go to state 7
    "continue"   shift, and go to state 8
    "for"        shift, and go to state 9
    "if"         shift, and go to state 10
    "nil"        shift, and go to state 11
    "proc"       shift, and go to state 12
    "return"     shift, and go to state 13
    "type"       shift, and go to state 14
    "var"        shift, and go to state 15
    "while"      shift, and go to state 16
    "echo"       shift, and go to state 17
    "readInt"    shift, and go to state 18
    "readFloat"  shift, and go to state 19
    "not"        shift, and go to state 20
    '-'          shift, and go to state 21
    '+'          shift, and go to state 22
    '$'          shift, and go to state 23
    '('          shift, and go to state 24
    '['          shift, and go to state 25

    sExpr                go to state 28
    symbol               go to state 29
    literal              go to state 30
    identOrLiteral       go to state 31
    tupleConstr          go to state 32
    arrayConstr          go to state 33
    forStmt              go to state 34
    primary              go to state 35
    exprStmt             go to state 36
    returnStmt           go to state 37
    breakStmt            go to state 38
    continueStmt         go to state 39
    ifStmt               go to state 40
    whileStmt            go to state 41
    simpleStmt           go to state 42
    complexOrSimpleStmt  go to state 116


State 73

    8 sExpr: sExpr "xor" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 117
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 74

    9 sExpr: sExpr "or" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 118
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 75

   10 sExpr: sExpr "and" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 119
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 76

   11 sExpr: sExpr "!=" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 120
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 77

   13 sExpr: sExpr ">=" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 121
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 78

   15 sExpr: sExpr "<=" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 122
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 79

   16 sExpr: sExpr "==" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 123
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 80

   20 sExpr: sExpr "mod" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 124
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 81

   21 sExpr: sExpr "div" . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 125
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 82

   12 sExpr: sExpr '>' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 126
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 83

   14 sExpr: sExpr '<' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 127
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 84

   17 sExpr: sExpr '-' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 128
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 85

   18 sExpr: sExpr '+' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 129
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 86

   19 sExpr: sExpr '%' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 130
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 87

   22 sExpr: sExpr '/' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 131
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 88

   23 sExpr: sExpr '*' . sExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 132
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35


State 89

   77 exprStmt: symbol "+=" . expr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 133
    primary         go to state 35


State 90

   78 exprStmt: symbol "*=" . expr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 134
    primary         go to state 35


State 91

   76 exprStmt: symbol '=' . expr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 135
    primary         go to state 35


State 92

   45 primarySuffix: '(' . exprList ')'
   46              | '(' . ')'

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    ')'       shift, and go to state 136
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    exprList        go to state 137
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 69
    primary         go to state 35


State 93

   47 primarySuffix: '[' . expr ']'

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 138
    primary         go to state 35


State 94

   48 primarySuffix: '.' . symbol

    IDENT  shift, and go to state 6

    symbol  go to state 139


State 95

   70 primary2: primarySuffix . primary2
   71         | primarySuffix .

    '('  shift, and go to state 92
    '['  shift, and go to state 93
    '.'  shift, and go to state 94

    $default  reduce using rule 71 (primary2)

    primarySuffix  go to state 95
    primary2       go to state 140


State 96

   68 primary: identOrLiteral primary2 .

    $default  reduce using rule 68 (primary)


State 97

   65 forStmt: "for" $@1 symbol . $@2 "in" expr ".." expr colonBody

    $default  reduce using rule 64 ($@2)

    $@2  go to state 141


State 98

   49 ifExpr: "if" condExpr .

    $default  reduce using rule 49 (ifExpr)


State 99

   50 condExpr: expr . colon expr elifCondExpr

    ':'  shift, and go to state 100

    colon  go to state 142


State 100

    7 colon: ':' .

    $default  reduce using rule 7 (colon)


State 101

   94 colonBody: colon . $@3 stmt

    $default  reduce using rule 93 ($@3)

    $@3  go to state 143


State 102

   83 ifStmt: "if" expr colonBody . INDEQ elifCondStmt
   84       | "if" expr colonBody . INDEQ elifCondStmt "else" colonBody
   85       | "if" expr colonBody .
   86       | "if" expr colonBody . INDEQ "else" colonBody

    INDEQ  shift, and go to state 144

    $default  reduce using rule 85 (ifStmt)


State 103

   61 paramListColon: ':' . typeDesc

    IDENT    shift, and go to state 6
    "tuple"  shift, and go to state 145
    "array"  shift, and go to state 146

    symbol        go to state 147
    inlTupleDecl  go to state 148
    arrayDecl     go to state 149
    typeDesc      go to state 150


State 104

   56 paramList: '(' . declColonCommaNoHang ')'
   57          | '(' . ')'

    IDENT  shift, and go to state 6
    ')'    shift, and go to state 151

    symbol                go to state 152
    declColon             go to state 153
    declColonCommaNoHang  go to state 154


State 105

   60 paramListColon: paramList . ':' typeDesc

    ':'  shift, and go to state 155


State 106

   90 routine: symbol paramListColon . '=' stmt
   91        | symbol paramListColon .

    '='  shift, and go to state 156

    $default  reduce using rule 91 (routine)


State 107

   92 typeDef: symbol '=' . typeDesc

    IDENT    shift, and go to state 6
    "tuple"  shift, and go to state 145
    "array"  shift, and go to state 146

    symbol        go to state 147
    inlTupleDecl  go to state 148
    arrayDecl     go to state 149
    typeDesc      go to state 157


State 108

   98 secVariable: INDG variable . serVariable DED

    INDEQ  shift, and go to state 158

    $default  reduce using rule 100 (serVariable)

    serVariable  go to state 159


State 109

   95 variable: symbol ':' . typeDesc '=' expr
   96         | symbol ':' . typeDesc

    IDENT    shift, and go to state 6
    "tuple"  shift, and go to state 145
    "array"  shift, and go to state 146

    symbol        go to state 147
    inlTupleDecl  go to state 148
    arrayDecl     go to state 149
    typeDesc      go to state 160


State 110

   89 whileStmt: "while" expr colonBody .

    $default  reduce using rule 89 (whileStmt)


State 111

   28 sExpr: '(' sExpr ')' .

    $default  reduce using rule 28 (sExpr)


State 112

   43 tupleConstr: '(' exprList ')' .

    $default  reduce using rule 43 (tupleConstr)


State 113

    6 comma: ',' .

    $default  reduce using rule 6 (comma)


State 114

   31 exprList: expr comma . exprList

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    exprList        go to state 161
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 69
    primary         go to state 35


State 115

   44 arrayConstr: '[' exprList ']' .

    $default  reduce using rule 44 (arrayConstr)


State 116

    2 module: module2 INDEQ complexOrSimpleStmt .
    4 module2: module2 INDEQ complexOrSimpleStmt .

    INDEQ     reduce using rule 4 (module2)
    $default  reduce using rule 2 (module)


State 117

    8 sExpr: sExpr . "xor" sExpr
    8      | sExpr "xor" sExpr .
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "or"   shift, and go to state 74
    "and"  shift, and go to state 75
    "!="   shift, and go to state 76
    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 8 (sExpr)


State 118

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
    9      | sExpr "or" sExpr .
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "and"  shift, and go to state 75
    "!="   shift, and go to state 76
    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 9 (sExpr)


State 119

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   10      | sExpr "and" sExpr .
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "!="   shift, and go to state 76
    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 10 (sExpr)


State 120

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   11      | sExpr "!=" sExpr .
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '>'    shift, and go to state 82
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 11 (sExpr)


State 121

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   13      | sExpr ">=" sExpr .
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 13 (sExpr)


State 122

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   15      | sExpr "<=" sExpr .
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 15 (sExpr)


State 123

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   16      | sExpr "==" sExpr .
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 16 (sExpr)


State 124

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   20      | sExpr "mod" sExpr .
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "div"  shift, and go to state 81
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 20 (sExpr)


State 125

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   21      | sExpr "div" sExpr .
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    '/'  shift, and go to state 87
    '*'  shift, and go to state 88

    $default  reduce using rule 21 (sExpr)


State 126

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   12      | sExpr '>' sExpr .
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    ">="   shift, and go to state 77
    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '<'    shift, and go to state 83
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 12 (sExpr)


State 127

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   14      | sExpr '<' sExpr .
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "<="   shift, and go to state 78
    "=="   shift, and go to state 79
    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '-'    shift, and go to state 84
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 14 (sExpr)


State 128

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   17      | sExpr '-' sExpr .
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '+'    shift, and go to state 85
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 17 (sExpr)


State 129

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   18      | sExpr '+' sExpr .
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '%'    shift, and go to state 86
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 18 (sExpr)


State 130

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   19      | sExpr '%' sExpr .
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr

    "mod"  shift, and go to state 80
    "div"  shift, and go to state 81
    '/'    shift, and go to state 87
    '*'    shift, and go to state 88

    $default  reduce using rule 19 (sExpr)


State 131

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   22      | sExpr '/' sExpr .
   23      | sExpr . '*' sExpr

    '*'  shift, and go to state 88

    $default  reduce using rule 22 (sExpr)


State 132

    8 sExpr: sExpr . "xor" sExpr
    9      | sExpr . "or" sExpr
   10      | sExpr . "and" sExpr
   11      | sExpr . "!=" sExpr
   12      | sExpr . '>' sExpr
   13      | sExpr . ">=" sExpr
   14      | sExpr . '<' sExpr
   15      | sExpr . "<=" sExpr
   16      | sExpr . "==" sExpr
   17      | sExpr . '-' sExpr
   18      | sExpr . '+' sExpr
   19      | sExpr . '%' sExpr
   20      | sExpr . "mod" sExpr
   21      | sExpr . "div" sExpr
   22      | sExpr . '/' sExpr
   23      | sExpr . '*' sExpr
   23      | sExpr '*' sExpr .

    $default  reduce using rule 23 (sExpr)


State 133

   77 exprStmt: symbol "+=" expr .

    $default  reduce using rule 77 (exprStmt)


State 134

   78 exprStmt: symbol "*=" expr .

    $default  reduce using rule 78 (exprStmt)


State 135

   76 exprStmt: symbol '=' expr .

    $default  reduce using rule 76 (exprStmt)


State 136

   46 primarySuffix: '(' ')' .

    $default  reduce using rule 46 (primarySuffix)


State 137

   45 primarySuffix: '(' exprList . ')'

    ')'  shift, and go to state 162


State 138

   47 primarySuffix: '[' expr . ']'

    ']'  shift, and go to state 163


State 139

   48 primarySuffix: '.' symbol .

    $default  reduce using rule 48 (primarySuffix)


State 140

   70 primary2: primarySuffix primary2 .

    $default  reduce using rule 70 (primary2)


State 141

   65 forStmt: "for" $@1 symbol $@2 . "in" expr ".." expr colonBody

    "in"  shift, and go to state 164


State 142

   50 condExpr: expr colon . expr elifCondExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 165
    primary         go to state 35


State 143

   94 colonBody: colon $@3 . stmt

    INTLIT      shift, and go to state 1
    FLOATLIT    shift, and go to state 2
    STRLIT      shift, and go to state 3
    CHARLIT     shift, and go to state 4
    BOOLLIT     shift, and go to state 5
    IDENT       shift, and go to state 6
    INDG        shift, and go to state 166
    "break"     shift, and go to state 7
    "continue"  shift, and go to state 8
    "nil"       shift, and go to state 11
    "return"    shift, and go to state 13
    "not"       shift, and go to state 20
    '-'         shift, and go to state 21
    '+'         shift, and go to state 22
    '$'         shift, and go to state 23
    '('         shift, and go to state 24
    '['         shift, and go to state 25

    sExpr           go to state 28
    symbol          go to state 29
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35
    exprStmt        go to state 36
    returnStmt      go to state 37
    breakStmt       go to state 38
    continueStmt    go to state 39
    simpleStmt      go to state 167
    stmt            go to state 168


State 144

   83 ifStmt: "if" expr colonBody INDEQ . elifCondStmt
   84       | "if" expr colonBody INDEQ . elifCondStmt "else" colonBody
   86       | "if" expr colonBody INDEQ . "else" colonBody

    INDEQ   shift, and go to state 169
    "else"  shift, and go to state 170

    elifCondStmt  go to state 171


State 145

   54 inlTupleDecl: "tuple" . '[' declColonCommaNoHang ']'

    '['  shift, and go to state 172


State 146

   55 arrayDecl: "array" . '[' INTLIT comma typeDesc ']'

    '['  shift, and go to state 173


State 147

   72 typeDesc: symbol .

    $default  reduce using rule 72 (typeDesc)


State 148

   73 typeDesc: inlTupleDecl .

    $default  reduce using rule 73 (typeDesc)


State 149

   74 typeDesc: arrayDecl .

    $default  reduce using rule 74 (typeDesc)


State 150

   61 paramListColon: ':' typeDesc .

    $default  reduce using rule 61 (paramListColon)


State 151

   57 paramList: '(' ')' .

    $default  reduce using rule 57 (paramList)


State 152

   53 declColon: symbol . ':' typeDesc

    ':'  shift, and go to state 174


State 153

   58 declColonCommaNoHang: declColon . comma declColonCommaNoHang
   59                     | declColon .

    ','  shift, and go to state 113

    $default  reduce using rule 59 (declColonCommaNoHang)

    comma  go to state 175


State 154

   56 paramList: '(' declColonCommaNoHang . ')'

    ')'  shift, and go to state 176


State 155

   60 paramListColon: paramList ':' . typeDesc

    IDENT    shift, and go to state 6
    "tuple"  shift, and go to state 145
    "array"  shift, and go to state 146

    symbol        go to state 147
    inlTupleDecl  go to state 148
    arrayDecl     go to state 149
    typeDesc      go to state 177


State 156

   90 routine: symbol paramListColon '=' . stmt

    INTLIT      shift, and go to state 1
    FLOATLIT    shift, and go to state 2
    STRLIT      shift, and go to state 3
    CHARLIT     shift, and go to state 4
    BOOLLIT     shift, and go to state 5
    IDENT       shift, and go to state 6
    INDG        shift, and go to state 166
    "break"     shift, and go to state 7
    "continue"  shift, and go to state 8
    "nil"       shift, and go to state 11
    "return"    shift, and go to state 13
    "not"       shift, and go to state 20
    '-'         shift, and go to state 21
    '+'         shift, and go to state 22
    '$'         shift, and go to state 23
    '('         shift, and go to state 24
    '['         shift, and go to state 25

    sExpr           go to state 28
    symbol          go to state 29
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    primary         go to state 35
    exprStmt        go to state 36
    returnStmt      go to state 37
    breakStmt       go to state 38
    continueStmt    go to state 39
    simpleStmt      go to state 167
    stmt            go to state 178


State 157

   92 typeDef: symbol '=' typeDesc .

    $default  reduce using rule 92 (typeDef)


State 158

   99 serVariable: INDEQ . variable serVariable

    IDENT  shift, and go to state 6

    symbol    go to state 56
    variable  go to state 179


State 159

   98 secVariable: INDG variable serVariable . DED

    DED  shift, and go to state 180


State 160

   95 variable: symbol ':' typeDesc . '=' expr
   96         | symbol ':' typeDesc .

    '='  shift, and go to state 181

    $default  reduce using rule 96 (variable)


State 161

   31 exprList: expr comma exprList .

    $default  reduce using rule 31 (exprList)


State 162

   45 primarySuffix: '(' exprList ')' .

    $default  reduce using rule 45 (primarySuffix)


State 163

   47 primarySuffix: '[' expr ']' .

    $default  reduce using rule 47 (primarySuffix)


State 164

   65 forStmt: "for" $@1 symbol $@2 "in" . expr ".." expr colonBody

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 182
    primary         go to state 35


State 165

   50 condExpr: expr colon expr . elifCondExpr

    "elif"  shift, and go to state 183
    "else"  shift, and go to state 184

    elifCondExpr  go to state 185


State 166

  116 stmt: INDG . stmt2 complexOrSimpleStmt DED

    $default  reduce using rule 118 (stmt2)

    stmt2  go to state 186


State 167

  115 stmt: simpleStmt .

    $default  reduce using rule 115 (stmt)


State 168

   94 colonBody: colon $@3 stmt .

    $default  reduce using rule 94 (colonBody)


State 169

   88 elifCondStmt: INDEQ . "elif" expr colonBody

    "elif"  shift, and go to state 187


State 170

   86 ifStmt: "if" expr colonBody INDEQ "else" . colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 188


State 171

   83 ifStmt: "if" expr colonBody INDEQ elifCondStmt .
   84       | "if" expr colonBody INDEQ elifCondStmt . "else" colonBody
   87 elifCondStmt: elifCondStmt . INDEQ "elif" expr colonBody

    INDEQ   shift, and go to state 189
    "else"  shift, and go to state 190

    $default  reduce using rule 83 (ifStmt)


State 172

   54 inlTupleDecl: "tuple" '[' . declColonCommaNoHang ']'

    IDENT  shift, and go to state 6

    symbol                go to state 152
    declColon             go to state 153
    declColonCommaNoHang  go to state 191


State 173

   55 arrayDecl: "array" '[' . INTLIT comma typeDesc ']'

    INTLIT  shift, and go to state 192


State 174

   53 declColon: symbol ':' . typeDesc

    IDENT    shift, and go to state 6
    "tuple"  shift, and go to state 145
    "array"  shift, and go to state 146

    symbol        go to state 147
    inlTupleDecl  go to state 148
    arrayDecl     go to state 149
    typeDesc      go to state 193


State 175

   58 declColonCommaNoHang: declColon comma . declColonCommaNoHang

    IDENT  shift, and go to state 6

    symbol                go to state 152
    declColon             go to state 153
    declColonCommaNoHang  go to state 194


State 176

   56 paramList: '(' declColonCommaNoHang ')' .

    $default  reduce using rule 56 (paramList)


State 177

   60 paramListColon: paramList ':' typeDesc .

    $default  reduce using rule 60 (paramListColon)


State 178

   90 routine: symbol paramListColon '=' stmt .

    $default  reduce using rule 90 (routine)


State 179

   99 serVariable: INDEQ variable . serVariable

    INDEQ  shift, and go to state 158

    $default  reduce using rule 100 (serVariable)

    serVariable  go to state 195


State 180

   98 secVariable: INDG variable serVariable DED .

    $default  reduce using rule 98 (secVariable)


State 181

   95 variable: symbol ':' typeDesc '=' . expr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 196
    primary         go to state 35


State 182

   65 forStmt: "for" $@1 symbol $@2 "in" expr . ".." expr colonBody

    ".."  shift, and go to state 197


State 183

   51 elifCondExpr: "elif" . expr colon expr elifCondExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 198
    primary         go to state 35


State 184

   52 elifCondExpr: "else" . colon expr

    ':'  shift, and go to state 100

    colon  go to state 199


State 185

   50 condExpr: expr colon expr elifCondExpr .

    $default  reduce using rule 50 (condExpr)


State 186

  116 stmt: INDG stmt2 . complexOrSimpleStmt DED
  117 stmt2: stmt2 . complexOrSimpleStmt INDEQ

    INTLIT       shift, and go to state 1
    FLOATLIT     shift, and go to state 2
    STRLIT       shift, and go to state 3
    CHARLIT      shift, and go to state 4
    BOOLLIT      shift, and go to state 5
    IDENT        shift, and go to state 6
    "break"      shift, and go to state 7
    "continue"   shift, and go to state 8
    "for"        shift, and go to state 9
    "if"         shift, and go to state 10
    "nil"        shift, and go to state 11
    "proc"       shift, and go to state 12
    "return"     shift, and go to state 13
    "type"       shift, and go to state 14
    "var"        shift, and go to state 15
    "while"      shift, and go to state 16
    "echo"       shift, and go to state 17
    "readInt"    shift, and go to state 18
    "readFloat"  shift, and go to state 19
    "not"        shift, and go to state 20
    '-'          shift, and go to state 21
    '+'          shift, and go to state 22
    '$'          shift, and go to state 23
    '('          shift, and go to state 24
    '['          shift, and go to state 25

    sExpr                go to state 28
    symbol               go to state 29
    literal              go to state 30
    identOrLiteral       go to state 31
    tupleConstr          go to state 32
    arrayConstr          go to state 33
    forStmt              go to state 34
    primary              go to state 35
    exprStmt             go to state 36
    returnStmt           go to state 37
    breakStmt            go to state 38
    continueStmt         go to state 39
    ifStmt               go to state 40
    whileStmt            go to state 41
    simpleStmt           go to state 42
    complexOrSimpleStmt  go to state 200


State 187

   88 elifCondStmt: INDEQ "elif" . expr colonBody

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 201
    primary         go to state 35


State 188

   86 ifStmt: "if" expr colonBody INDEQ "else" colonBody .

    $default  reduce using rule 86 (ifStmt)


State 189

   87 elifCondStmt: elifCondStmt INDEQ . "elif" expr colonBody

    "elif"  shift, and go to state 202


State 190

   84 ifStmt: "if" expr colonBody INDEQ elifCondStmt "else" . colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 203


State 191

   54 inlTupleDecl: "tuple" '[' declColonCommaNoHang . ']'

    ']'  shift, and go to state 204


State 192

   55 arrayDecl: "array" '[' INTLIT . comma typeDesc ']'

    ','  shift, and go to state 113

    comma  go to state 205


State 193

   53 declColon: symbol ':' typeDesc .

    $default  reduce using rule 53 (declColon)


State 194

   58 declColonCommaNoHang: declColon comma declColonCommaNoHang .

    $default  reduce using rule 58 (declColonCommaNoHang)


State 195

   99 serVariable: INDEQ variable serVariable .

    $default  reduce using rule 99 (serVariable)


State 196

   95 variable: symbol ':' typeDesc '=' expr .

    $default  reduce using rule 95 (variable)


State 197

   65 forStmt: "for" $@1 symbol $@2 "in" expr ".." . expr colonBody

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 206
    primary         go to state 35


State 198

   51 elifCondExpr: "elif" expr . colon expr elifCondExpr

    ':'  shift, and go to state 100

    colon  go to state 207


State 199

   52 elifCondExpr: "else" colon . expr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 208
    primary         go to state 35


State 200

  116 stmt: INDG stmt2 complexOrSimpleStmt . DED
  117 stmt2: stmt2 complexOrSimpleStmt . INDEQ

    INDEQ  shift, and go to state 209
    DED    shift, and go to state 210


State 201

   88 elifCondStmt: INDEQ "elif" expr . colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 211


State 202

   87 elifCondStmt: elifCondStmt INDEQ "elif" . expr colonBody

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 212
    primary         go to state 35


State 203

   84 ifStmt: "if" expr colonBody INDEQ elifCondStmt "else" colonBody .

    $default  reduce using rule 84 (ifStmt)


State 204

   54 inlTupleDecl: "tuple" '[' declColonCommaNoHang ']' .

    $default  reduce using rule 54 (inlTupleDecl)


State 205

   55 arrayDecl: "array" '[' INTLIT comma . typeDesc ']'

    IDENT    shift, and go to state 6
    "tuple"  shift, and go to state 145
    "array"  shift, and go to state 146

    symbol        go to state 147
    inlTupleDecl  go to state 148
    arrayDecl     go to state 149
    typeDesc      go to state 213


State 206

   65 forStmt: "for" $@1 symbol $@2 "in" expr ".." expr . colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 214


State 207

   51 elifCondExpr: "elif" expr colon . expr elifCondExpr

    INTLIT    shift, and go to state 1
    FLOATLIT  shift, and go to state 2
    STRLIT    shift, and go to state 3
    CHARLIT   shift, and go to state 4
    BOOLLIT   shift, and go to state 5
    IDENT     shift, and go to state 6
    "if"      shift, and go to state 45
    "nil"     shift, and go to state 11
    "not"     shift, and go to state 20
    '-'       shift, and go to state 21
    '+'       shift, and go to state 22
    '$'       shift, and go to state 23
    '('       shift, and go to state 24
    '['       shift, and go to state 25

    sExpr           go to state 46
    symbol          go to state 47
    literal         go to state 30
    identOrLiteral  go to state 31
    tupleConstr     go to state 32
    arrayConstr     go to state 33
    ifExpr          go to state 48
    expr            go to state 215
    primary         go to state 35


State 208

   52 elifCondExpr: "else" colon expr .

    $default  reduce using rule 52 (elifCondExpr)


State 209

  117 stmt2: stmt2 complexOrSimpleStmt INDEQ .

    $default  reduce using rule 117 (stmt2)


State 210

  116 stmt: INDG stmt2 complexOrSimpleStmt DED .

    $default  reduce using rule 116 (stmt)


State 211

   88 elifCondStmt: INDEQ "elif" expr colonBody .

    $default  reduce using rule 88 (elifCondStmt)


State 212

   87 elifCondStmt: elifCondStmt INDEQ "elif" expr . colonBody

    ':'  shift, and go to state 100

    colon      go to state 101
    colonBody  go to state 216


State 213

   55 arrayDecl: "array" '[' INTLIT comma typeDesc . ']'

    ']'  shift, and go to state 217


State 214

   65 forStmt: "for" $@1 symbol $@2 "in" expr ".." expr colonBody .

    $default  reduce using rule 65 (forStmt)


State 215

   51 elifCondExpr: "elif" expr colon expr . elifCondExpr

    "elif"  shift, and go to state 183
    "else"  shift, and go to state 184

    elifCondExpr  go to state 218


State 216

   87 elifCondStmt: elifCondStmt INDEQ "elif" expr colonBody .

    $default  reduce using rule 87 (elifCondStmt)


State 217

   55 arrayDecl: "array" '[' INTLIT comma typeDesc ']' .

    $default  reduce using rule 55 (arrayDecl)


State 218

   51 elifCondExpr: "elif" expr colon expr elifCondExpr .

    $default  reduce using rule 51 (elifCondExpr)
