letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

# Preprocess all comments, remove all empty lines

module = complexOrSimpleStmt ^* IND{=}
module = (complexOrSimpleStmt (IND{=} complexOrSimpleStmt)*)?

comma = ','
semicolon = ';'
colon = ':'
prefixOperator = OP8 | OP10
simpleExpr = orExpr (OP1 orExpr)*
orExpr = andExpr (OP3 andExpr)*
andExpr = cmpExpr (OP4 cmpExpr)*
cmpExpr = sliceExpr (OP5 sliceExpr)*
sliceExpr = ampExpr (OP6 ampExpr)*
ampExpr = plusExpr (OP7 plusExpr)*
plusExpr = mulExpr (OP8 mulExpr)*
mulExpr = primary (OP9 primary)*
symbol = IDENT
exprColonExpr = expr (':' expr)?
exprList = expr ^+ comma
exprList = expr (comma expr)*
exprColonExprList = exprColonExpr (comma exprColonExpr)* (comma)?
dotExpr = expr '.'  symbol
castExpr = 'cast' '['  typeDesc  ']' '('  expr  ')'
literal = BOOL_LIT | INT_LIT | FLOAT_LIT | STR_LIT | CHAR_LIT | NIL
identOrLiteral = symbol | literal | arrayConstr | castExpr | tupleConstr
tupleConstr = '('  (exprColonExpr comma?)*  ')'
arrayConstr = '['  (exprColonExpr comma?)*  ']'
primarySuffix = '(' (exprColonExpr comma?)* ')'
      | '['  exprColonExprList  ']'
      | '.'  symbol
condExpr = expr colon expr 
        ('elif' expr colon expr )*
         'else' colon expr
ifExpr = 'if' condExpr
declColonEquals = symbol (comma symbol)* comma?
                  (':'  typeDesc) ('='  expr)?
inlTupleDecl = 'tuple'
    '['   (declColonEquals (comma)?)+   ']'
extTupleDecl = 'tuple'
     IND{>} declColonEquals (IND{=} declColonEquals)* DED
arrayDecl = 'array' '['  INT_LIT comma typeDesc ']'

paramList = '(' declColonEquals ^* (comma) ')'
paramList = '(' (declColonEquals ((comma) declColonEquals)*)? ')'

paramListColon = paramList? (':'  typeDesc)?
forStmt = 'for' (symbol ^+ comma) 'in' expr colon stmt
forStmt = 'for' (symbol (comma symbol)*) 'in' expr colon stmt
expr = ifExpr
      / simpleExpr
primary = prefixOperator* identOrLiteral primarySuffix* 
        | '(' expr ')'
typeDesc = symbol | enum | extTupleDecl | inlTupleDecl | arrayDecl
exprStmt = simpleExpr
returnStmt = 'return'  expr?
breakStmt = 'break'  symbol
continueStmt = 'continue' 
condStmt = expr colon stmt
           (IND{=} 'elif' expr colon stmt)*
           (IND{=} 'else' colon stmt)?
ifStmt = 'if' condStmt
whileStmt = 'while' expr colon stmt
blockStmt = 'block' symbol? colon stmt
routine =  symbol
  paramListColon ('=' stmt)?
section(RULE) =  RULE / (IND{>} (RULE)^+IND{=} DED)
enum = 'enum'  (symbol  comma?)+
typeDef = symbol '='  typeDesc
varTuple = '('  symbol ^+ comma  ')' '='  expr
varTuple = '('  symbol (comma symbol)* ')' '='  expr
colonBody = colon stmt
variable = (varTuple / declColonEquals) colonBody?
simpleStmt = ((returnStmt | breakStmt
           | continueStmt) 
           / exprStmt)
complexOrSimpleStmt = (ifStmt | whileStmt | forStmt
                    | blockStmt | 'proc' routine
                    | 'type' section(typeDef)
                    | ('let' | 'var') section(variable))
                    / simpleStmt
stmt = (IND{>} complexOrSimpleStmt^+ IND{=} DED)
     / simpleStmt IND{=}
stmt = (IND{>} complexOrSimpleStmt (IND{=} complexOrSimpleStmt)* DED)
     / simpleStmt IND{=}