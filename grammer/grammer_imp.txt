letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

# Preprocess all comments, remove all empty lines and add one blank line at end

module = complexOrSimpleStmt ^* IND{=}
comma = ','
semicolon = ';'
colon = ':'
operator = OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 | OP10
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'not' | '..'
prefixOperator = '$' | '-' | '+'
optInd = IND{>}?
optPar = (IND{>} | IND{=})?
simpleExpr = orExpr (OP1 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = IDENT
exprColonExpr = expr (':' expr)?
exprList = expr ^+ comma
exprColonExprList = exprColonExpr (comma exprColonExpr)* (comma)?
dotExpr = expr '.' optInd symbol
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'if' | 'while' | 'for' | 'block' | 'let' | 'var'
literal = BOOL_LIT | INT_LIT | UINT_LIT | FLOAT_LIT | STR_LIT | CHAR_LIT | NIL
identOrLiteral = symbol | literal | arrayConstr | castExpr | tupleConstr
tupleConstr = '(' optInd (exprColonExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonExpr comma?)* ')'
      | '[' optInd exprColonExprList optPar ']'
      | '.' optInd symbol
condExpr = expr colon expr optInd
        ('elif' expr colon expr optInd)*
         'else' colon expr
ifExpr = 'if' condExpr
declColonEquals = symbol (comma symbol)* comma?
                  (':' optInd typeDesc) ('=' optInd expr)?
inlTupleDecl = 'tuple'
    '[' optInd  (declColonEquals (comma)?)*  optPar ']'
extTupleDecl = 'tuple'
     (IND{>} declColonEquals (IND{=} declColonEquals)*)?
arrayDecl = 'array' '[' optInd INT_LIT comma typeDesc optPar']'
arrayDecl = 'array' '[' INT_LIT comma typeDesc ']'
paramList = '(' declColonEquals ^* (comma) ')'
paramListColon = paramList? (':' optInd typeDesc)?
forStmt = 'for' (symbol ^+ comma) 'in' expr colon stmt
expr = ifExpr
      / simpleExpr
primary = prefixOperator* identOrLiteral primarySuffix*
typeDesc = symbol | enum | extTupleDecl | inlTupleDecl | arrayDecl
exprStmt = simpleExpr
returnStmt = 'return' optInd expr?
breakStmt = 'break' optInd symbol
continueStmt = 'continue' 
condStmt = expr colon stmt
           (IND{=} 'elif' expr colon stmt)*
           (IND{=} 'else' colon stmt)?
ifStmt = 'if' condStmt
whileStmt = 'while' expr colon stmt
blockStmt = 'block' symbol? colon stmt
routine = optInd symbol
  paramListColon ('=' stmt)?
section(RULE) =  RULE / (IND{>} (RULE)^+IND{=} DED)
enum = 'enum' optInd (symbol optInd comma?)+
typeDef = symbol '=' optInd typeDesc
varTuple = '(' optInd symbol ^+ comma optPar ')' '=' optInd expr
colonBody = colon stmt
variable = (varTuple / declColonEquals) colonBody?
simpleStmt = ((returnStmt | breakStmt
           | continueStmt) 
           / exprStmt)
complexOrSimpleStmt = (ifStmt | whileStmt | forStmt
                    | blockStmt | 'proc' routine
                    | 'type' section(typeDef)
                    | ('let' | 'var') section(variable))
                    / simpleStmt
stmt = (IND{>} complexOrSimpleStmt^+ IND{=} DED)
     / simpleStmt IND{=}