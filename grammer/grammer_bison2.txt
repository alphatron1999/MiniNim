letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

# Preprocess all comments, remove all empty lines

module = complexOrSimpleStmt ^* IND{=}
module = (complexOrSimpleStmt (IND{=} complexOrSimpleStmt)*)?

module = complexOrSimpleStmt module2 | 
module2 = IND{=} complexOrSimpleStmt module2 |

comma = ','
semicolon = ';'
colon = ':'
prefixOperator = OP8 | OP10

simpleExpr = orExpr

orExpr = andExpr (OP3 andExpr)*
orExpr = andExpr OP3 orExpr | andExpr

andExpr = cmpExpr (OP4 cmpExpr)*
andExpr = cmpExpr OP4 andExpr | cmpExpr

cmpExpr = sliceExpr (OP5 sliceExpr)*
cmpExpr = sliceExpr OP5 cmpExpr | sliceExpr

sliceExpr = ampExpr (OP6 ampExpr)*
sliceExpr = ampExpr OP6 sliceExpr | ampExpr

ampExpr = plusExpr (OP7 plusExpr)*
ampExpr = plusExpr OP7 ampExpr | plusExpr

plusExpr = mulExpr (OP8 mulExpr)*
plusExpr = mulExpr OP8 plusExpr | mulExpr

mulExpr = primary (OP9 primary)*
mulExpr = primary OP9 mulExpr | primary

symbol = IDENT

exprColonExpr = expr (':' expr)?
exprColonExpr = expr | expr ':' expr

symbolColonExpr = symbol ':' expr

exprList = expr ^+ comma
exprList = expr (comma expr)*
exprList = expr comma exprList | expr

exprColonExprList = exprColonExpr (comma exprColonExpr)* (comma)?
exprColonExprList = exprColonExpr comma exprColonExprList | exprColonExpr comma | exprColonExpr

dotExpr = expr '.'  symbol
castExpr = 'cast' '['  typeDesc  ']' '('  expr  ')'
literal = BOOL_LIT | INT_LIT | FLOAT_LIT | STR_LIT | CHAR_LIT | NIL
identOrLiteral = symbol | literal | arrayConstr | castExpr | tupleConstr


tupleArrElts = exprColonExpr comma tupleArrElts | exprColonExpr |
tupleElts =  symbolColonExpr comma tupleSymbolElts | symbolColonExpr |


tupleConstr = '('  (exprColonExpr comma?)*  ')'
tupleConstr = '(' tupleElts ')' | '(' exprList ')'

arrayConstr = '['  (exprColonExpr comma?)*  ']'
arrayConstr = '[' exprList ']'


primarySuffix = '(' (exprColonExpr comma?)* ')' | '['  exprColonExprList  ']' | '.'  symbol
primarySuffix = '(' exprList ')' | '('')' | '['  INT_LIT  ']' | '.'  symbol

condExpr = expr colon expr ('elif' expr colon expr )* 'else' colon expr
condExpr = expr colon expr elifCondExpr 
elifCondExpr = 'elif' expr colon expr elifCondExpr | 'else' colon expr

ifExpr = 'if' condExpr


# symbolComma = symbol comma symbolComma | symbol | 
symbolCommaNoHang = symbol comma symbolCommaNoHang | symbol

declColon = symbol (comma symbol)* comma? (':'  typeDesc)
declColon = symbol (':'  typeDescFunc)

inlTupleDecl = 'tuple' '['   (declColon (comma)?)+   ']'
inlTupleDecl = 'tuple' '['   declColonComma   ']'
declColonComma = declColon comma declColonComma | declColon comma | declColon


extTupleDecl = 'tuple' IND{>} declColon (IND{=} declColon)* DED
extTupleDecl = 'tuple' IND{>} declColon extTupleDecl2 DED
extTupleDecl2 = IND{=} declColon extTupleDecl2 | 


arrayDecl = 'array' '['  INT_LIT comma typeDesc ']'


paramList = '(' declColon ^* (comma) ')'
paramList = '(' (declColon ((comma) declColon)*)? ')'
paramList = '(' declColonCommaNoHang ')' | '(' ')'
declColonCommaNoHang = declColon comma declColonCommaNoHang | declColon 

paramListColon = paramList? (':'  typeDesc)?
paramListColon = paramList (':'  typeDescFunc) | (':'  typeDesc) |
typeDescFunc = typeDesc | 'var' typeDesc

forStmt = 'for' (symbol ^+ comma) 'in' expr colon stmt
forStmt = 'for' (symbol (comma symbol)*) 'in' expr colon stmt
forStmt = 'for' ( symbolCommaNoHang ) 'in' expr colon stmt


expr = ifExpr/ simpleExpr
expr = ifExpr | simpleExpr

primary = prefixOperator* identOrLiteral primarySuffix* | '(' expr ')'
primary = primary1 identOrLiteral primary2 | '(' expr ')'
primary1 = prefixOperator primary1 | 
primary2 = primarySuffix primary2 |

typeDesc = symbol | enum | extTupleDecl | inlTupleDecl | arrayDecl
exprStmt = simpleExpr | varTuple '=' expr | symbol OP1 expr
returnStmt = 'return' expr | 'return'
breakStmt = 'break' symbol
continueStmt = 'continue' 

condStmt = expr colon stmt (IND{=} 'elif' expr colon stmt)* (IND{=} 'else' colon stmt)?
condStmt = expr colon stmt elifCondStmt IND{=} 'else' colon stmt | expr colon stmt elifCondStmt
elifCondStmt = IND{=} 'elif' expr colon stmt elifCondStmt |

ifStmt = 'if' condStmt
whileStmt = 'while' expr colon stmt

blockStmt = 'block' symbol? colon stmt
blockStmt = 'block' symbol colon stmt | 'block' colon stmt

routine =  symbol paramListColon ('=' stmt)?
routine =  symbol paramListColon ('=' stmt) | symbol paramListColon

enum = 'enum'  (symbol  comma?)+
enum = 'enum'  symbolCommaNoHang

typeDef = symbol '='  typeDesc

varTuple = '('  symbol ^+ comma  ')' '='  expr
varTuple = '('  symbol (comma symbol)* ')' '='  expr
varTuple = '('  symbolCommaNoHang ')' '='  expr


colonBody = colon stmt

variable = (varTuple / declColon)
variable = varTuple | declColon '=' expr | declColon

secVariable = variable | (IND{>} variable serVariable DED)
serVariable = IND{=} variable serVariable | 

simpleStmt = ((returnStmt | breakStmt | continueStmt) / exprStmt)
simpleStmt = returnStmt | breakStmt | continueStmt | exprStmt

sectionTypeDef = section(typeDef)

complexOrSimpleStmt = (ifStmt | whileStmt | forStmt | blockStmt | 'proc' routine | 'type' typeDef | ('let' | 'var') secVariable | simpleStmt


stmt = (IND{>} complexOrSimpleStmt^+ IND{=} DED) / simpleStmt
stmt = IND{>} complexOrSimpleStmt  DED | simpleStmt
stmt2 = IND{=} complexOrSimpleStmt stmt2 | 