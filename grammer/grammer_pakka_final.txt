letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

# Preprocess all comments, remove all empty lines

module = complexOrSimpleStmt module2 | 
module2 = INDEQ complexOrSimpleStmt module2 |

comma = ","
colon = ":"
prefixOperator = "not" 
               | "+"
               | "-"
               | "$"

/*

%left "xor"
%left "or" 
%left "and"
%left "!=" 
%left ">" 
%left ">=" 
%left "<" 
%left "<=" 
%left "==" 
%left ".." 
%left "-" 
%left "+" 
%left "%" 
%left "mod"
%left "div"
%left "/" 
%left "*" 

*/

simpleExpr : sExpr
sExpr : sExpr "xor" sExpr  //OP3
      | sExpr "or" sExpr
      | sExpr "and" sExpr //OP4
      | sExpr "!=" sExpr //OP5
      | sExpr ">" sExpr 
      | sExpr ">=" sExpr 
      | sExpr "<" sExpr 
      | sExpr "<=" sExpr 
      | sExpr "==" sExpr 
      | sExpr ".." sExpr //OP6
      | sExpr "-" sExpr //OP8
      | sExpr "+" sExpr 
      | sExpr "%" sExpr //OP9
      | sExpr "mod" sExpr 
      | sExpr "div" sExpr 
      | sExpr "/" sExpr 
      | sExpr "*" sExpr 
      | primary

symbol : IDENT

exprColonExpr : expr 
              | expr ":" expr
symbolColonExpr : symbol ":" expr
exprList : expr comma exprList 
         | expr

dotExpr : expr "."  symbol
castExpr : "cast" "["  typeDesc  "]" "("  expr  ")"
literal : BOOL_LIT 
        | INT_LIT 
        | FLOAT_LIT 
        | STR_LIT 
        | CHAR_LIT 
        | "nil"
identOrLiteral : symbol 
               | literal 
               | arrayConstr 
               | castExpr 
               | tupleConstr

tupleElts :  symbolColonExpr comma tupleSymbolElts 
          | symbolColonExpr 
          |
tupleConstr : "(" tupleElts ")" 
            | "(" exprList ")"

arrayConstr : "[" exprList "]"

primarySuffix : "(" exprList ")" 
              | "("")" 
              | "["  expr  "]" 
              | "."  symbol

ifExpr : "if" condExpr
condExpr : expr colon expr elifCondExpr 
elifCondExpr : "elif" expr colon expr elifCondExpr 
             | "else" colon expr

symbolCommaNoHang : symbol comma symbolCommaNoHang 
                  | symbol

declColon : symbol (":"  typeDescFunc)

inlTupleDecl : "tuple" "["   declColonComma   "]"
declColonComma : declColon comma declColonComma 
               | declColon comma 
               | declColon

extTupleDecl : "tuple" INDG declColon extTupleDecl2 DED
extTupleDecl2 : INDEQ declColon extTupleDecl2 
              | 

arrayDecl : "array" "["  INT_LIT comma typeDesc "]"

paramList : "(" declColonCommaNoHang ")" 
          | "(" ")"
declColonCommaNoHang : declColon comma declColonCommaNoHang 
                     | declColon 

paramListColon : paramList (":"  typeDescFunc) 
               | (":"  typeDesc) 
               |
typeDescFunc : typeDesc 
             | "var" typeDesc

forStmt : "for" ( symbolCommaNoHang ) "in" expr colonBody

expr : ifExpr 
     | simpleExpr

primary : primary1 identOrLiteral primary2 
        | "(" expr ")"
primary1 : prefixOperator primary1 
         | 
primary2 : primarySuffix primary2 
         |

typeDesc : symbol 
         | enum 
         | extTupleDecl 
         | inlTupleDecl 
         | arrayDecl
exprStmt : simpleExpr 
         | varTuple "=" expr 
         | symbol OP1 expr
returnStmt : "return" expr 
           | "return"
breakStmt : "break" symbol
continueStmt : "continue" 

condStmt : expr colonBody elifCondStmt INDEQ "else" colonBody 
         | expr colonBody elifCondStmt
elifCondStmt : INDEQ "elif" expr colonBody elifCondStmt 
             |

ifStmt : "if" condStmt
whileStmt : "while" expr colonBody
blockStmt : "block" symbol colonBody 
          | "block" colonBody
routine :  symbol paramListColon ("=" stmt) 
        | symbol paramListColon

enum : "enum"  symbolCommaNoHang

typeDef : symbol "="  typeDesc

varTuple : "("  symbolCommaNoHang ")" "="  expr

colonBody : colon stmt

variable : varTuple 
         | declColon "=" expr 
         | declColon

secVariable : variable 
            | (INDG variable serVariable DED)
serVariable : INDEQ variable serVariable 
            | 

simpleStmt : returnStmt 
            | breakStmt 
            | continueStmt 
            | exprStmt

complexOrSimpleStmt : ifStmt 
                    | whileStmt 
                    | forStmt 
                    | blockStmt 
                    | "proc" routine 
                    | "type" typeDef 
                    | "let" secVariable 
                    | "var" secVariable 
                    | simpleStmt

stmt : INDG complexOrSimpleStmt stmt2 DED 
     | simpleStmt
stmt2 : INDEQ complexOrSimpleStmt stmt2 
      | 