letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

# Preprocess all comments, remove all empty lines and add one blank line at end

module = complexOrSimpleStmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
operator = OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 | OP10
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'not' | '..'
prefixOperator = '$' | '-' | '+'
optInd = COMMENT? IND{>}?
optPar = (IND{>} | IND{=})?
simpleExpr = orExpr (OP1 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = IDENT
exprColonEqExpr = expr (':' expr)?
exprList = expr ^+ comma
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
dotExpr = expr '.' optInd symbol
qualifiedIdent = symbol ('.' optInd symbol)?
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'if' | 'while' | 'for' | 'block' | 'let' | 'var'
literal = BOOL_LIT | INT_LIT | UINT_LIT | FLOAT_LIT | STR_LIT | CHAR_LIT | NIL
identOrLiteral = symbol | literal | arrayConstr | castExpr | tupleConstr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')'
      | '[' optInd exprColonEqExprList optPar ']'
condExpr = expr colon expr optInd
        ('elif' expr colon expr optInd)*
         'else' colon expr
ifExpr = 'if' condExpr
identVis = symbol
declColonEquals = identVis (comma identVis)* comma?
                  (':' optInd typeDesc) ('=' optInd expr)?
inlTupleDecl = 'tuple'
    '[' optInd  (declColonEquals (comma)?)*  optPar ']'
extTupleDecl = 'tuple'
    COMMENT? (IND{>} declColonEquals (IND{=} declColonEquals)*)?
arrayDecl = 'array' '[' INT_LIT comma typeDesc ']'
paramList = '(' declColonEquals ^* (comma) ')'
paramListColon = paramList? (':' optInd typeDesc)?
forStmt = 'for' (identVis ^+ comma) 'in' expr colon stmt
expr = ifExpr
      / simpleExpr
primary = prefixOperator* identOrLiteral primarySuffix*
typeDesc = symbol | enum | extTupleDecl | inlTupleDecl | arrayDecl
exprStmt = simpleExpr
returnStmt = 'return' optInd expr?
breakStmt = 'break' optInd symbol
continueStmt = 'continue' 
condStmt = expr colon stmt COMMENT?
           (IND{=} 'elif' expr colon stmt)*
           (IND{=} 'else' colon stmt)?
ifStmt = 'if' condStmt
whileStmt = 'while' expr colon stmt
blockStmt = 'block' symbol? colon stmt
indAndComment = (IND{>} COMMENT)? | COMMENT?
routine = optInd identVis
  paramListColon ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(RULE) = COMMENT? RULE / (IND{>} (RULE / COMMENT)^+IND{=} DED)
enum = 'enum' optInd (symbol optInd comma?)+
typeDef = identVis '=' optInd typeDesc
            indAndComment?
varTuple = '(' optInd identVis ^+ comma optPar ')' '=' optInd expr
colonBody = colon stmt
variable = (varTuple / declColonEquals) colonBody? indAndComment
simpleStmt = ((returnStmt | breakStmt
           | continueStmt | commentStmt) 
           / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whileStmt | forStmt
                    | blockStmt | 'proc' routine
                    | 'type' section(typeDef)
                    | ('let' | 'var') section(variable))
                    / simpleStmt
stmt = (IND{>} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt (IND{=} / ';')