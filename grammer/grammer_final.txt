letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

module = stmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
operator = OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 | OP10
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | '..'
prefixOperator = operator
optInd = COMMENT? IND?
optPar = (IND{>} | IND{=})?
simpleExpr = orExpr (OP1 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = IDENT
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr ^+ comma
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
dotExpr = expr '.' optInd symbol
qualifiedIdent = symbol ('.' optInd symbol)?
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'if' | 'while' | 'for' | 'block' | 'let' | 'var'
par = '(' optInd
          simpleExpr (  (':' expr (',' exprColonEqExpr ^+ ',' )? ) ) 
          optPar ')'
literal = BOOL_LIT | INT_LIT | UINT_LIT | FLOAT_LIT | STR_LIT | CHAR_LIT | NIL
identOrLiteral = symbol | literal
               | par | arrayConstr | castExpr | tupleConstr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')'
      | '[' optInd exprColonEqExprList optPar ']'
condExpr = expr colon expr optInd
        ('elif' expr colon expr optInd)*
         'else' colon expr
ifExpr = 'if' condExpr
identVis = symbol OPR?  # postfix position
identVisDot = symbol '.' optInd symbol OPR?
declColonEquals = identVis (comma identVis)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = IDENT (comma IDENT)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
inlTupleDecl = 'tuple'
    '[' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']'
extTupleDecl = 'tuple'
    COMMENT? (IND{>} identColonEquals (IND{=} identColonEquals)*)?
tupleClass = 'tuple'
paramList = '(' declColonEquals ^* (comma/semicolon) ')'
paramListColon = paramList? (':' optInd typeDesc)?
procExpr = 'proc' paramListColon ('=' COMMENT? stmt)?
forStmt = 'for' (identVis ^+ comma) 'in' expr colon stmt
expr = ifExpr
      / simpleExpr
typeKeyw = 'var' | 'ptr' | 'tuple' | 'proc' | 'enum'
primary = typeKeyw optInd typeDesc
        /  prefixOperator* identOrLiteral primarySuffix*
typeDesc = symbol ('=' expr)?
postExprBlocks = ':' stmt? ( IND{=} 'elif' expr ':' stmt
                           | IND{=} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr colonBody? )
         / ( expr ^+ comma
             postExprBlocks
           ))?
returnStmt = 'return' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'continue' optInd expr?
condStmt = expr colon stmt COMMENT?
           (IND{=} 'elif' expr colon stmt)*
           (IND{=} 'else' colon stmt)?
ifStmt = 'if' condStmt
whileStmt = 'while' expr colon stmt
blockStmt = 'block' symbol? colon stmt
blockExpr = 'block' symbol? colon stmt
indAndComment = (IND{>} COMMENT)? | COMMENT?
routine = optInd identVis
  paramListColon ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(RULE) = COMMENT? RULE / (IND{>} (RULE / COMMENT)^+IND{=} DED)
enum = 'enum' optInd (symbol optInd ('=' optInd expr COMMENT?)? comma?)+
typeDef = identVisDot '=' optInd typeDesc
            indAndComment?
varTuple = '(' optInd identVis ^+ comma optPar ')' '=' optInd expr
colonBody = colon stmt postExprBlocks?
variable = (varTuple / identColonEquals) colonBody? indAndComment
simpleStmt = ((returnStmt | breakStmt
           | continueStmt | commentStmt) 
           / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whileStmt | forStmt
                    | blockStmt | 'proc' routine
                    | 'type' section(typeDef)
                    | ('let' | 'var') section(variable))
                    / simpleStmt
stmt = (IND{>} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt ^+ ';'