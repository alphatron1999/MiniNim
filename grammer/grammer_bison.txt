letter ::= 'A'..'Z' | 'a'..'z'
digit ::= '0'..'9' 
IDENT ::= letter ( ['_'] (letter | digit) )*

INT_LIT = digit+
STR_LIT ::= '"' .* '"'
CHAR_LIT ::= '''.'''
FLOAT_LIT = digit+ '.' digit+
UINT_LIT = INT_LIT ('u' | 'U')

KEYW =  addr and as block break cast const continue
elif else end enum for
if in is isnot let mod nil not notin
object of or proc return
tuple type using var when while xor

Operator Precedence: https://nim-lang.org/docs/manual.html#syntax-precedence

# Preprocess all comments, remove all empty lines

module = complexOrSimpleStmt ^* IND{=}
module = (complexOrSimpleStmt (IND{=} complexOrSimpleStmt)*)?

module = complexOrSimpleStmt module2 | 
module2 = IND{=} complexOrSimpleStmt module2 |

comma = ','
semicolon = ';'
colon = ':'
prefixOperator = OP8 | OP10

simpleExpr = orExpr (OP1 orExpr)*
simpleExpr = orExpr OP1 simpleExpr | orExpr

orExpr = andExpr (OP3 andExpr)*
orExpr = andExpr OP3 orExpr | andExpr

andExpr = cmpExpr (OP4 cmpExpr)*
andExpr = cmpExpr OP4 andExpr | cmpExpr

cmpExpr = sliceExpr (OP5 sliceExpr)*
cmpExpr = sliceExpr OP5 cmpExpr | sliceExpr

sliceExpr = ampExpr (OP6 ampExpr)*
sliceExpr = ampExpr OP6 sliceExpr | ampExpr

ampExpr = plusExpr (OP7 plusExpr)*
ampExpr = plusExpr OP7 ampExpr | plusExpr

plusExpr = mulExpr (OP8 mulExpr)*
plusExpr = mulExpr OP8 plusExpr | mulExpr

mulExpr = primary (OP9 primary)*
mulExpr = primary OP9 mulExpr | primary

symbol = IDENT

exprColonExpr = expr (':' expr)?
exprColonExpr = expr | expr ':' expr

exprList = expr ^+ comma
exprList = expr (comma expr)*
exprList = expr comma exprList | expr

exprColonExprList = exprColonExpr (comma exprColonExpr)* (comma)?
exprColonExprList = exprColonExpr comma exprColonExprList | exprColonExpr comma | exprColonExpr

dotExpr = expr '.'  symbol
castExpr = 'cast' '['  typeDesc  ']' '('  expr  ')'
literal = BOOL_LIT | INT_LIT | FLOAT_LIT | STR_LIT | CHAR_LIT | NIL
identOrLiteral = symbol | literal | arrayConstr | castExpr | tupleConstr


tupleArrElts =  exprColonExpr comma tupleArrElts | exprColonExpr |

tupleConstr = '('  (exprColonExpr comma?)*  ')'
tupleConstr = '(' tupleArrElts ')'

arrayConstr = '['  (exprColonExpr comma?)*  ']'
arrayConstr = '[' tupleArrElts ']'


primarySuffix = '(' (exprColonExpr comma?)* ')' | '['  exprColonExprList  ']' | '.'  symbol
primarySuffix = '(' tupleArrElts ')' | '['  exprColonExprList  ']' | '.'  symbol

condExpr = expr colon expr ('elif' expr colon expr )* 'else' colon expr
condExpr = expr colon expr (elifCondExpr) 'else' colon expr
elifCondExpr = 'elif' expr colon expr elifCondExpr | 

ifExpr = 'if' condExpr


symbolComma = symbol comma symbolComma | symbol | 
symbolCommaNoHang = symbol comma symbolComma | symbol

declColonEquals = symbol (comma symbol)* comma? (':'  typeDesc) ('='  expr)?
declColonEquals = symbolComma (':'  typeDesc) ('='  expr) | symbolComma (':'  typeDesc)


inlTupleDecl = 'tuple' '['   (declColonEquals (comma)?)+   ']'
inlTupleDecl = 'tuple' '['   DeclColonEqualsComma   ']'
declColonEqualsComma = declColonEquals comma declColonEqualsComma | declColonEquals comma | declColonEquals

extTupleDecl = 'tuple' IND{>} declColonEquals (IND{=} declColonEquals)* DED
extTupleDecl = 'tuple' IND{>} declColonEquals extTupleDecl2 DED
extTupleDecl2 = IND{=} declColonEquals extTupleDecl2 | 


arrayDecl = 'array' '['  INT_LIT comma typeDesc ']'


paramList = '(' declColonEquals ^* (comma) ')'
paramList = '(' (declColonEquals ((comma) declColonEquals)*)? ')'
paramList = '(' declColonEqualsCommaNoHang ')' | '(' ')'
declColonEqualsCommaNoHang = declColonEquals comma declColonEqualsCommaNoHang | declColonEquals 

paramListColon = paramList? (':'  typeDesc)?
paramListColon = paramList (':'  typeDesc) | paramList | (':'  typeDesc) |


forStmt = 'for' (symbol ^+ comma) 'in' expr colon stmt
forStmt = 'for' (symbol (comma symbol)*) 'in' expr colon stmt
forStmt = 'for' ( symbolCommaNoHang ) 'in' expr colon stmt


expr = ifExpr/ simpleExpr
expr = ifExpr | simpleExpr

primary = prefixOperator* identOrLiteral primarySuffix* | '(' expr ')'
primary = primary1 identOrLiteral primary2 | '(' expr ')'
primary1 = prefixOperator primary1 | 
primary2 = primarySuffix primary2 |

typeDesc = symbol | enum | extTupleDecl | inlTupleDecl | arrayDecl
exprStmt = simpleExpr
returnStmt = 'return'  expr | 'return'
breakStmt = 'break'  symbol
continueStmt = 'continue' 

condStmt = expr colon stmt (IND{=} 'elif' expr colon stmt)* (IND{=} 'else' colon stmt)?
condStmt = expr colon stmt elifCondStmt IND{=} 'else' colon stmt | expr colon stmt elifCondStmt
elifCondStmt = IND{=} 'elif' expr colon stmt elifCondStmt |

ifStmt = 'if' condStmt
whileStmt = 'while' expr colon stmt

blockStmt = 'block' symbol? colon stmt
blockStmt = 'block' symbol colon stmt | 'block' colon stmt

routine =  symbol paramListColon ('=' stmt)?
routine =  symbol paramListColon ('=' stmt) | symbol paramListColon

/*pending
section(RULE) =  RULE / (IND{>} (RULE)^+IND{=} DED)
*/

enum = 'enum'  (symbol  comma?)+
enum = 'enum'  symbolComma

typeDef = symbol '='  typeDesc

varTuple = '('  symbol ^+ comma  ')' '='  expr
varTuple = '('  symbol (comma symbol)* ')' '='  expr
varTuple = '('  symbolCommaNoHang ')' '='  expr


colonBody = colon stmt

variable = (varTuple / declColonEquals) colonBody?
variable = varTuple colonBody | varTuple | declColonEquals colonBody | declColonEquals

simpleStmt = ((returnStmt | breakStmt | continueStmt) / exprStmt)
simpleStmt = returnStmt | breakStmt | continueStmt | exprStmt

/*pending
complexOrSimpleStmt = (ifStmt | whileStmt | forStmt | blockStmt | 'proc' routine | 'type' section(typeDef) | ('let' | 'var') section(variable)) / simpleStmt
complexOrSimpleStmt = (ifStmt | whileStmt | forStmt | blockStmt | 'proc' routine | 'type' section(typeDef) | ('let' | 'var') section(variable)) | simpleStmt
*/

stmt = (IND{>} complexOrSimpleStmt^+ IND{=} DED) / simpleStmt IND{=}
stmt = IND{>} complexOrSimpleStmt  DED | simpleStmt IND{=}
stmt2 = IND{=} complexOrSimpleStmt stmt2 | 